--================GENERAL UTILITY FUNCTIONS==================

--Given an index set U and a function f:U->V computes the subset
--of U minimizing the value of f
minRespTo = (U, f) -> (
    m := min apply(U, f);
    toList select(U, u->f(u)==m)
    ) 

--================ALGEBRA UTILITY FUNCTIONS===================

--Given a ring, outputs a random linear form
randomLinear = R -> sum apply(R_*,v->random coefficientRing R*v)

--Max_j betti_{1,j}
topDeg = I -> max apply(flatten entries mingens I, g -> (degree g)_0)

--Computes postulation number of ideal
postN = I -> (
    i = -1; 
    P = hilbertPolynomial(I);
    while P(i)!=hilbertFunction(i,I) do i = i+1; 
    i)

--probabilistic algorithm for computing gin
probGin = I -> (
    R := ring I;
    randomVars := apply(R_*, x->randomLinear R);
    phi := map(R,R,randomVars);
    ideal flatten entries leadTerm phi(I)
    )

--=========PARTITION UTILITY FUNCTIONS===================

--Generates Partitions of r with at most d distinct parts.
partits = (mu,delta) -> (delete(null, apply((partitions(mu,delta+1)), i -> if (sum unique new List from i) == mu then new List from i)))

--Gives a random partition given an upper and lower bound for lamdba_1
randomPartition = (lower, upper) -> (
    r := random(lower,upper);
    ls := {r};
    while not r==0 do (
	r=random(0,r-1);
	if not zero r then ls = append(ls,r);
	);
    print ls;
    ls
    )

--Computes the difference sequence of a given sequence
--Returns a sequence, input can be sequence or list
diffSeq = lambda -> apply(0..length lambda-2, i-> lambda_i-lambda_(i+1))

--checks to see if a sequence is nonDecreasing
isNonDecr = ls -> (
    all(0..length ls-2, i-> ls_i>=ls_(i+1))
    )

isRevLex = lambda -> (
    for i from 0 to (length lambda)-3 do if not (lambda#i-lambda#(i+1)==1) then return false;
    true
    )
    
--=================PARTITION TO ALGEBRA FUNCTIONS========

--Converts a partition into a list of monomials
partitionToMonomials = lambda -> (
    local i,j; 
    R := QQ[symbol x,symbol y,symbol z];
    flatten for i from 0 to length lambda-1 list for j from 0 to lambda#i-1 list x^(lambda#0-1-i-j)*y^j*z^i
    )

--Converts a partition to an ideal
partitionToIdeal = lambda -> ideal(partitionToMonomials lambda)

--Given a list of monomials, creates the k-subalgebra
monlsToAlg = mls -> ker map(ring mls_0, (coefficientRing ring mls_0)[symbol t_1..symbol t_(length mls)],mls)
    
--Outputs the defining ideal of the algebra generated by the monomials associated
--to the partition.
partitionToAlg = {kk => QQ, useD=>0} >> opt -> lambda -> (
    local delta,i,j; 
    if opt.useD==0 then delta=lambda_0-1 else delta=opt.useD; assert(lambda_0<=delta+1);
    R := (opt.kk)[symbol x,symbol y,symbol z];
    mls := flatten for i from 0 to length lambda-1 list for j from 0 to lambda_i-1 list x^(delta-i-j)*y^j*z^i;
    ker map(R,(opt.kk)[symbol t_1..symbol t_(length mls), MonomialOrder => GLex], mls)
)

--Generates all F(I) 
genInmd = (mu,delta) -> apply(partits(mu,delta),x->(partitionToAlg(x,useD=>delta),x))

--Checks if algebra corresponding to partition is normal
isNormalPartition = lambda -> (
    m := partitionToMonomials lambda;
    n := gens normalToricRing m;
    # difference (new Set from m, new Set from n)
    )

--==========CONVERSION TO NORMALIZ================
--Formats partition so normaliz can process it
partitionToMatrix = lambda -> (
    local i,j;
    matrix flatten for i from 0 to length lambda-1 list for j from 0 to lambda#i-1 list {lambda#0-1-i-j,j,i}
)

--Feed partition into normaliz
partitionToNormaliz = lambda -> normaliz(partitionToMatrix lambda, "polytope")

--============MULTIPLICITY COMPUTATIONS==========

--Returns indices of border in decreasing order
getBorder = lambda -> (
    k := length lambda-1;
    border := {0};
    f := 0;
    while f != k do (
	border = prepend(first minRespTo(f+1..k, i->((lambda_f-lambda_i)/(i-f),i)),border);
	f = first border;
	);
    border
    )

--Checks if the set of points corresponding to a partition is convex
isConvex = lambda -> (
    remainingBorder = getBorder lambda;
    while length border != 1 do (
	f := remainingBorder_0;
	s := remainingBorder_1;
	m := (lambda_f-lambda_s)/(s-f);
       	if any(1..f-s-1, t->floor(lambda_f+m*t)>lambda_(f-t)) then return false;
	remainingBorder = remove(boundary,remainingBorder);
	);
    return true;
    )

convexArea = lambda -> (
    B := (length getBorder lambda)+(length lambda -1)+(last lambda)-1+(first lambda)-2;
    (sum lambda - B)+B/2 -1
    )

minI3mudelta = (mu,delta) -> minRespTo(select(partits(mu,delta),lambda -> isConvex(lambda)),lambda -> convexArea(lambda))

--checks if set of points is regular meaning border size is maximized
isBordered = lambda -> length getBorder(lambda) == length lambda

--computes area for regular set of points
borderedArea = lambda -> sum lambda - (length lambda-1) - 1/2*(first lambda+last lambda)

--======DISPLAYING DATA==========

netList table(toList(10..30),{6,7,8,9,10},minI3mudelta)
netList table(toList(10..30),{6,7},(i,j)->apply(minI3mudelta(i,j),k->hilbertPolynomial(partitionToAlg k,Projective=>false)))  
netList table(toList(5..30),{3,4,5,6,7},(i,j)->any(minI3mudelta(i,j), k->(first k == j+1) or (last k == 1)))  
netList table(toList(5..30),{3,4,5,6,7,8,9,10},(i,j)->any(minI3mudelta(i,j),isBordered))  

ff=(mu,delta)->minRespTo(select(partits(mu,delta), isBordered),borderedArea)

checkSameFirst = (S) -> (
    select(S, i -> first (i_0) == first (i_1))
    )