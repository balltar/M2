--Generates Partitions of r with at most d distinct parts.
partits = (r,d) -> (delete(null, apply((partitions(r,d+1)), i -> if (sum unique new List from i) == r then new List from i)))

--Converts a partition into a list of monomials
partitionToMonomials = P -> (
    local i,j,mls; R := QQ[symbol x,symbol y,symbol z];
    mls := flatten for i from 0 to length P-1 list for j from 0 to P#i-1 list x^(P#0-1-i-j)*y^j*z^i;
    --print mls;
    mls
    )

--Converts a partition to an ideal
partitionToIdeal = P -> (
    ideal(partitionToMonomials P)
    ) 

--Outputs the coordinate vector of either an ideal generated by monomials or 
--a list of monomials
coordinates =  L -> (
    if isIdeal L then L=L_*;
    apply(L, g -> drop(first exponents g,1))
    )

--Outputs a membership function for display purposes
coordinatesToTable = C -> 
    (i,j) -> if member({j,i},C) then "*" else " "

--Given a list of monomials and lambda_1, outputs an ascii art display    
listToPicture = (L,d) -> (
    netList table(new List from (0..d), new List from (0..d), coordinatesToTable coordinates L)
    )
    
--Outputs the defining ideal of the algebra generated by the monomials associated
--to the partition.
partitionToAlg = {useRing => QQ, useD=>0} >> opt -> P -> (
    local d; if opt.useD==0 then d=P#0-1 else d=opt.useD; assert(P#0<=d+1);
    local i,j,mls; R := (opt.useRing)[symbol x,symbol y,symbol z];
    mls := flatten for i from 0 to length P-1 list for j from 0 to P#i-1 list x^(d-i-j)*y^j*z^i;
    --print mls;
    ker map(R,(opt.useRing)[symbol t_1..symbol t_(length mls), MonomialOrder => GLex], mls)
)

--Formats partition so normaliz can process it
partitionToMatrix = P -> (
    local i,j;
    matrix flatten for i from 0 to length P-1 list for j from 0 to P#i-1 list {P#0-1-i-j,j,i}
)

--Feed partition into normaliz
partitionToNormaliz = P -> (
    normaliz(partitionToMatrix P, "polytope")
    )

--Generates all algebras from partitions of r of degree d
generateBorelAlgebras = (r,d) -> apply(partits(r,d),x->(partitionToAlg(x,useD=>d),x))

--Reads off coefficients of Q(t), the numerator of the reduced hilbert zeros.
--The option extend zeroes adds zeroes up to the dimension of the module.
hvec = {extendZeroes => false} >> opt -> M -> (
    e := flatten entries (coefficients numerator reduceHilbert hilbertSeries M)_1;
    if opt.extendZeroes then for i from 0 to (3-(length e))-1 do e = append(e,0);
    e)

--sorts based on first entry
dumbsort = lsls -> (
    local temp,sorted,m,f,i;
    temp := lsls;
    sorted := {};
    f := for i in temp list i_0;
    while not temp == {} do (
	m := min f;
	for i in temp do if i_0==m then sorted=append(sorted,i);
	temp = select(temp, i -> not i_0 == m);
	f = for i in temp list i_0;
	);
    sorted
    )

--Computes postulation number
postN = I -> (
    i = -1; 
    P = hilbertPolynomial(I);
    while P(i)!=hilbertFunction(i,I) do i = i+1; 
    i)

allHvecs = (r,d) -> for i in dumbsort apply(
    generateBorelAlgebras(r,d),x->(
       	hvec(x_0,extendZeroes=>true),
	x_1,
	--max apply((ideal flatten entries mingens x_0)_*,y->(degree y)_0),
	--hilbertPolynomial(x_0,Projective=>false),
	--hilbertFunction(2,x_0),
	postN x_0
	--mRegularity x_0 - 1;
	)) do print i

--Checks for r=3 and given u and d if algebra corresponding to minimal hilbert
--polynomial is normal (assumes nonCM are never minimal)
normalityCheck = (u,d) -> (
    ls :=  dumbsort apply(
    	generateBorelAlgebras(u,d),x->(
       	hvec(x_0,extendZeroes=>true),
	x_1
	));
    m := partitionToMonomials (ls_0)_1;
    n := gens normalToricRing m;
    # difference (new Set from m, new Set from n)
    )

maxDeg = I -> max apply(flatten entries mingens I, g -> (degree g)_0)

--Gives a random partition given an upper and lower bound for lamdba_1
randomPartition = (lower, upper) -> (
    r := random(lower,upper);
    ls := {r};
    while not r==0 do (
	r=random(0,r-1);
	if not zero r then ls = append(ls,r);
	);
    print ls;
    ls
    )

--randomly finds a partition such that there's a generator of its defining ideal that
--have degree >2
randomFind = n -> (
    select(for i from 1 to 1000 list (
	    r := randomPartition(n,n); 
	    (maxDeg partitionToAlg r,r))
	, x->x_0>2)
    )

--Given a ring, outputs a random linear combination
randomLinear = R -> sum apply(R_*,v->random coefficientRing R*v)

--probabilistic algorithm for computing gin
probGin = I -> (
    R := ring I;
    randomVars := apply(R_*, x->randomLinear R);
    phi := map(R,R,randomVars);
    ideal flatten entries leadTerm phi(I)
    )
